#!/usr/bin/env node
(function() {
  var OptionParser, action, args, create, die, extend, fs, json, options, opts, parse, parser, piped, progress, run, say, spawn, usage,
    __slice = Array.prototype.slice;

  fs = require("fs");

  say = function() {
    var splat;
    splat = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return console.error.apply(null, splat);
  };

  die = function() {
    var splat;
    splat = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (splat.length) console.error.apply(null, splat);
    return process.exit(1);
  };

  spawn = require("child_process").spawn;

  OptionParser = require("coffee-script/lib/coffee-script/optparse").OptionParser;

  options = {
    create: [],
    json: [],
    run: [["-p", "--processes [COUNT]", "run multiple processes"]],
    progress: []
  };

  args = process.argv.slice(2);

  if (opts = options[args[0]]) {
    action = args.shift();
  } else {
    action = "piped";
    opts = options.run;
  }

  parser = new OptionParser(opts);

  usage = function(message) {
    process.stderr.write("error: " + message + "\n");
    process.stderr.write(parser.help());
    process.stderr.write("\n");
    return process.exit(1);
  };

  try {
    options = parser.parse(args);
  } catch (e) {
    usage("Invalid arguments.");
  }

  piped = function() {
    var formatter, runner;
    formatter = spawn(__filename, ["progress"], {
      customFds: [-1, 1, 2]
    });
    formatter.on("exit", function(code) {
      if (code !== 0) return process.exit(code);
    });
    runner = spawn(__filename, ["run"].concat(args));
    runner.stderr.on("data", function(chunk) {});
    runner.stdout.pipe(formatter.stdin);
    return runner.on("exit", function(code) {
      if (code !== 0) return process.exit(code);
    });
  };

  json = function() {
    var object;
    object = {};
    process.stdin.resume();
    return parse(process.stdin, function(program) {
      var comment, file, message, passed, skip, time, todo;
      switch (program.type) {
        case "run":
          return object[program.file] = {
            time: program.time,
            expected: program.expected,
            tests: []
          };
        case "plan":
          return object[program.file].expected = program.expected;
        case "test":
          message = program.message, file = program.file, time = program.time, passed = program.passed, skip = program.skip, todo = program.todo, comment = program.comment;
          return object[file].tests.push({
            message: message,
            time: time,
            passed: passed,
            skip: skip,
            todo: todo,
            comment: comment
          });
        case "exit":
          return extend(object[program.file], {
            actual: program.actual,
            duration: program.time - program.start,
            code: program.code
          });
        case "eof":
          process.stdout.write(JSON.stringify(object, null, 2));
          return process.stdout.write("\n");
      }
    });
  };

  progress = (function() {
    var colorize, dotted, green, red, styling;
    colorize = function(color) {
      return function(text) {
        return "" + color + text + "\u001B[39m";
      };
    };
    red = colorize("\u001B[31m");
    green = colorize("\u001B[32m");
    dotted = function(count) {
      return Array(Math.max(count - 1, 0)).join(".");
    };
    styling = function(program, terminal) {
      var color, dots, file, icon, status, summary, time;
      if (program.passed < program.actual || program.bailed) {
        extend(program, {
          status: "Failure",
          color: red,
          icon: "\u2718"
        });
      }
      time = "" + (program.time - program.start);
      if (time.length < 3) time = ("00" + time).slice(-3);
      time = ("     " + time).replace(/(\d{3})$/, ".$1").slice(-5);
      summary = "(" + program.passed + "/" + program.expected + ") " + time;
      dots = dotted(66 - program.file.length - summary.length);
      color = program.color, icon = program.icon, file = program.file, status = program.status;
      return " " + (color(icon)) + " " + file + " " + dots + " " + summary + " " + (color(status)) + terminal;
    };
    return function() {
      var displayed, durations, failed, programs;
      process.stdin.resume();
      durations = {};
      displayed = null;
      programs = {};
      failed = [];
      return parse(process.stdin, function(program) {
        var candidates, file, k, summary, v, _name, _ref;
        if (program.type === "run") {
          displayed || (displayed = program.file);
          if (programs[_name = program.file] == null) {
            programs[_name] = {
              actual: 0,
              color: green,
              file: program.file,
              start: Number.MAX_VALUE,
              status: "Success",
              time: 0,
              passed: 0,
              expected: program.expected,
              icon: "\u2713"
            };
          }
        }
        if (program.type === "eof") {
          summary = {
            actual: 0,
            passed: 0,
            expected: 0,
            time: 0,
            start: Number.MAX_VALUE,
            count: 0
          };
          for (file in programs) {
            program = programs[file];
            summary.count++;
            summary.actual += program.actual || 0;
            summary.passed += program.passed || 0;
            summary.expected += program.expected || 0;
            if (!program.time) continue;
            summary.start = Math.min(summary.start, program.start);
            summary.time = Math.max(summary.time, program.time);
          }
          summary.file = "Total tests: " + summary.count;
          extend(summary, summary.passed === summary.expected ? {
            icon: "\u2713",
            status: "Success",
            color: green
          } : {
            icon: "\u2718",
            status: "Failure",
            color: red
          });
          process.stdout.write(Array(79).join("_") + "\n");
          return process.stdout.write(styling(summary, "\n"));
        } else {
          programs[program.file].duration = program.time - program.start;
          switch (program.type) {
            case "test":
              if (file === displayed && process.stdout.isTTY && process.env["TRAVIS"] !== "true") {
                return process.stdout.write(styling(programs[program.file], "\r"));
              }
              break;
            case "bail":
              return programs[program.file].bailed = true;
            case "exit":
              extend(programs[program.file], program);
              process.stdout.write(styling(programs[program.file], "\n"));
              if (program.code !== 0) failed.push(program);
              candidates = (function() {
                var _results;
                _results = [];
                for (k in programs) {
                  v = programs[k];
                  _results.push(v);
                }
                return _results;
              })();
              candidates.sort(function(a, b) {
                return a.duration - b.duration;
              });
              return displayed = (_ref = candidates.pop()) != null ? _ref.file : void 0;
          }
        }
      });
    };
  })();

  parser = {
    plan: function(plan) {
      var expected, match;
      if (match = /^1..(\d+)$/.exec(plan)) expected = match[1];
      if (expected) expected = parseInt(expected, 10);
      if (!isNaN(expected)) {
        return {
          expected: parseInt(match[1], 10)
        };
      }
    },
    bailout: function(bailout) {
      var match, message;
      if (match = /^Bail out!(?:\s+(.*))?$/.exec(bailout)) {
        message = match[1];
        return {
          message: message
        };
      }
    },
    assertion: function(assert) {
      var comment, failed, match, message, ok, skip, todo, _ref, _ref2, _ref3;
      if (match = /^(not\s+)?ok\s+\d+\s*(.*?)\s*$/.exec(assert)) {
        _ref = match.slice(1), failed = _ref[0], message = _ref[1];
        ok = !(failed != null);
        _ref2 = [null, false, false], comment = _ref2[0], skip = _ref2[1], todo = _ref2[2];
        if (message != null) {
          _ref3 = message.split(/\s+#\s+/, 2), message = _ref3[0], comment = _ref3[1];
          if (comment != null) {
            if (skip = (match = /^skip\s(.*)$/i.exec(comment)) != null) {
              comment = match[1];
            }
            if (todo = (match = /^todo\s(.*)$/i.exec(comment)) != null) {
              comment = match[1];
            }
          }
        }
        return {
          ok: ok,
          message: message,
          comment: comment,
          skip: skip,
          todo: todo
        };
      }
    }
  };

  extend = function() {
    var destination, key, source, sources, value, _i, _len;
    destination = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (key in source) {
        value = source[key];
        destination[key] = value;
      }
    }
    return destination;
  };

  parse = function(stream, callback) {
    var count, out, programs;
    programs = {};
    out = [""][0];
    count = 0;
    stream.setEncoding("utf8");
    return stream.on("data", function(chunk) {
      var code, expected, file, line, lines, match, program, record, rest, time, type, _i, _len, _ref, _results;
      out += chunk;
      lines = out.split(/\n/);
      out = lines.pop();
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        count++;
        if (!(match = /^(\d+)\s+(\w+)\s+([^\s]+)\s*(.*)$/.exec(line))) {
          throw new Error("cannot parse line " + count);
        }
        _ref = match.slice(1), time = _ref[0], type = _ref[1], file = _ref[2], rest = _ref[3];
        time = parseInt(time);
        program = programs[file] || (programs[file] = {
          passed: 0,
          actual: 0
        });
        switch (type) {
          case "test":
            record = parser.assertion(rest);
            program.actual++;
            if (record.ok) program.passed++;
            extend(record, program, {
              time: time,
              file: file,
              type: type
            });
            _results.push(callback(record));
            break;
          case "run":
            program.start = time;
            _results.push(callback(extend(program, {
              time: time,
              type: type,
              file: file
            })));
            break;
          case "plan":
            expected = parseInt(rest, 10);
            _results.push(callback(extend(program, {
              time: time,
              file: file,
              type: type,
              expected: expected
            })));
            break;
          case "bail":
            record = parser.bailout(rest);
            program.bailed = true;
            extend(record, program, {
              time: time,
              file: file,
              type: type
            });
            _results.push(callback(record));
            break;
          case "exit":
            code = parseInt(rest, 10);
            if (isNaN(code)) {
              throw new Error("cannot read exit code " + code + " on line " + count);
            }
            record = extend({}, program, {
              code: code,
              file: file,
              type: type,
              time: time
            });
            _results.push(callback(record));
            break;
          case "err":
          case "out":
            _results.push(callback({
              time: time,
              type: type,
              file: file,
              line: rest
            }));
            break;
          case "eof":
            _results.push(callback({
              time: time,
              type: type
            }));
            break;
          default:
            throw new Error("unknown type " + type);
        }
      }
      return _results;
    });
  };

  run = function() {
    var dirname, displayed, emit, execute, failures, i, key, next, parallel, program, programs, value, _i, _len, _results;
    programs = options.arguments;
    parallel = {};
    for (_i = 0, _len = programs.length; _i < _len; _i++) {
      program = programs[_i];
      if (/\s+/.test(program)) {
        throw new Error("program names cannot contain spaces: " + program);
      }
      dirname = /^(.*)\/.*/.exec(program)[1];
      parallel[dirname] || (parallel[dirname] = {
        programs: [],
        time: 0,
        running: true
      });
      parallel[dirname].programs.push(program);
    }
    parallel = (function() {
      var _results;
      _results = [];
      for (key in parallel) {
        value = parallel[key];
        _results.push(value);
      }
      return _results;
    })();
    failures = [];
    displayed = 0;
    emit = function(file, type, message) {
      message = message != null ? " " + message : "";
      type = ("" + type + "      ").slice(0, 4);
      return process.stdout.write("" + (+new Date()) + " " + type + " " + file + message + "\n");
    };
    execute = function(program, index) {
      var bailed, err, out, test;
      emit(program, "run");
      test = spawn(program);
      bailed = false;
      err = "";
      test.stderr.setEncoding("utf8");
      test.stderr.on("data", function(chunk) {
        var line, lines, _j, _len2, _results;
        err += chunk;
        lines = err.split(/\n/);
        err = lines.pop();
        _results = [];
        for (_j = 0, _len2 = lines.length; _j < _len2; _j++) {
          line = lines[_j];
          _results.push(emit(program, "err", line));
        }
        return _results;
      });
      out = "";
      test.stdout.setEncoding("utf8");
      test.stdout.on("data", function(chunk) {
        var line, lines, plan, _j, _len2, _results;
        out += chunk;
        lines = out.split(/\n/);
        out = lines.pop();
        _results = [];
        for (_j = 0, _len2 = lines.length; _j < _len2; _j++) {
          line = lines[_j];
          if (bailed) {
            _results.push(emit(program, "out", line));
          } else if (parser.assertion(line)) {
            _results.push(emit(program, "test", line));
          } else if (plan = parser.plan(line)) {
            _results.push(emit(program, "plan", plan.expected));
          } else if (parser.bailout(line)) {
            _results.push(emit(program, "bail", line));
          } else {
            _results.push(emit(program, "out", line));
          }
        }
        return _results;
      });
      return test.on("exit", function(code) {
        var time;
        emit(program, "exit", code);
        parallel[index].time = time = 0;
        if (parallel[index].programs.length) {
          return execute(parallel[index].programs.shift(), index);
        } else if (next < parallel.length) {
          parallel[index].running = false;
          if (displayed === index) displayed = next + 1;
          index = next++;
          return execute(parallel[index].programs.shift(), index);
        } else {
          return emit("*", "eof");
        }
      });
    };
    next = options.processes || 1;
    _results = [];
    for (i = 0; 0 <= next ? i < next : i > next; 0 <= next ? i++ : i--) {
      if (parallel[i]) {
        _results.push(execute(parallel[i].programs.shift(), i));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  create = function() {
    var argument, async, directory, file, harness, harnessFile, inspect, name, output, plan, shebang, signature, stat, _i, _len, _ref, _ref2;
    signature = [];
    plan = 0;
    async = "";
    harness = "./harness";
    _ref = options.arguments;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      argument = _ref[_i];
      if (argument === "_") {
        async = ", _";
      } else if (/^t(?:est)?\//.test(argument)) {
        name = argument;
      } else if (/^\./.test(argument)) {
        harness = argument;
      } else if (/^\d+/.test(argument)) {
        plan = parseInt(argument, 10);
      } else {
        signature.push(argument);
      }
    }
    try {
      if (fs.statSync(name)) die("test file already exists: " + name);
    } catch (e) {
      if (e.code !== "ENOENT") throw e;
    }
    _ref2 = /^(.*)\/(.*)/.exec(name).slice(1), directory = _ref2[0], file = _ref2[1];
    harnessFile = "" + directory + "/" + harness + ".coffee";
    try {
      stat = fs.statSync(harnessFile);
    } catch (e) {
      if (e.code === "ENOENT") die("cannot find harness " + harnessFile);
      throw e;
    }
    shebang = /^(.*)\n/.exec(fs.readFileSync(harnessFile, "utf8"))[1];
    fs.writeFileSync(name, "" + shebang + "\nrequire(\"" + harness + "\") 0, (context) ->\n  process.stdout.write JSON.stringify Object.keys context\n  process.stdout.write \"\\n\"\n", "utf8");
    fs.chmodSync(name, 0755);
    output = "";
    inspect = spawn(name);
    inspect.stdout.setEncoding("utf8");
    inspect.stdout.on("data", function(chunk) {
      return output += chunk;
    });
    return inspect.on("exit", function(code) {
      var arg, missing, _j, _len2;
      fs.unlinkSync(name);
      if (code !== 0) die("cannot generate inspection program");
      if (async) {
        shebang += "\nreturn if not require(\"streamline/module\")(module)";
      }
      json = JSON.parse(output.split(/\n/)[1]);
      missing = [];
      for (_j = 0, _len2 = signature.length; _j < _len2; _j++) {
        arg = signature[_j];
        if (json.indexOf(arg) === -1) missing.push(arg);
      }
      if (missing.length) {
        die("harness does not provide " + (missing.join(", ")) + "\ntry: " + (json.join(", ")));
      }
      fs.writeFileSync(name, "" + shebang + "\nrequire(\"" + harness + "\") " + plan + ", ({ " + (signature.join(", ")) + " }" + async + ") ->\n\n  # Here be dragons.\n", "utf8");
      return fs.chmodSync(name, 0755);
    });
  };

  ({
    create: create,
    piped: piped,
    json: json,
    run: run,
    progress: progress
  })[action]();

}).call(this);
